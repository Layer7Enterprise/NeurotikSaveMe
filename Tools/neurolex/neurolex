#! /usr/bin/env ruby

require 'socket'

#10010 => wordA wordC
def vectorToWords vector
  words = []

  vector.split("").each_with_index do |x, i|
    if vector[i] == "1"
      words << @lexicon[i]
    end
  end

  words = words.join(" ")
  return words
end

#wordA wordC => "10010"
def words_to_vector words, inverted_lexicon
  vector = "0"*inverted_lexicon.keys.count

  words.split(" ").uniq.each_with_index do |x, i|
    vector[inverted_lexicon[x]] = "1"
  end

  vector
end

file = ARGV[0]
type = ARGV[1]
portFrom = ARGV[2]
portTo = ARGV[3]

def help
  puts "NeuroLex - Lexicon Swiss Knife"
  puts "[gen]erate a lexicon list from a set of words"
    puts "\tgen wordA wordB wordC wordD"
    puts "\t(hint) use > operator to save to a lexicon file"
  puts "Convert a word to vector [w2v]"
    puts "\tw2v file word"
  puts "Convert a word to vector [w2vd] interactively"
    puts "\tw2vi file out_port delay"
  puts "Convert incomming vectors to stdout"
    puts "\tv2wi file in_port"
  puts "Generate a basic training file for word pairing"
    puts "\tgen_train_pair file pair_file"
    puts "\t(hint) use > operator to save a basic training file"
    puts "\tPair file is seperated pair of words e.g. 'a b\\nc d'"
  exit
end

#Generate lexicon compatible 'stream' from a list of words
def gen
  words = ARGV[1..-1]
  inverted_lexicon= {}

  words.uniq.each_with_index do |word, index|
    inverted_lexicon[word] = index
  end

  words.each do |word|
    vector = words_to_vector word, inverted_lexicon
    puts "#{word} #{vector}"
  end
end

def file_to_lexicons file_name
  lexicon = {}
  reverse_lexicon = {}

  File.open file_name, "r" do |file|
    while !file.eof?
      word, vector = file.readline.split(" ")
      lexicon[vector] = word
      reverse_lexicon[word] = vector
    end
  end

  return [lexicon, reverse_lexicon]
end

def w2v
  file_name = ARGV[1]
  word = ARGV[2]

  File.open file_name, "r" do |file|
    while !file.eof?
      vector_word, vector = file.readline.split(" ")
      if word == vector_word
        puts vector
        return
      end
    end
  end
end

def join_vectors vectorA, vectorB=nil
  new_vector = "0" * vectorA.length

  vectorA.length.times do |i|
    if vectorB.nil?
      return vectorA
    elsif
      if vectorA[i] == "1" or vectorB[i] == "1"
        new_vector[i] = "1"
      end
    end
  end

  return new_vector
end

#Interactive mode
def w2vi
  file_name = ARGV[1]
  out_port = ARGV[2]
  delay = ARGV[3]

  lexicon, reverse_lexicon = file_to_lexicons file_name

  socket = UDPSocket.new

  loop do
    words = $stdin.gets.strip.split(" ")
    words.each do |word|
      vector = reverse_lexicon[word]
      if vector.nil?
        puts "Not found..."
        next
      end

      blank_half = "0"*vector.length
      vector = vector + blank_half

      socket.send vector, 0, "127.0.0.1", out_port
      sleep delay.to_f / 1000.0
    end
  end
end

def v2wi
  file_name = ARGV[1]
  in_port = ARGV[2]

  lexicon, reverse_lexicon = file_to_lexicons file_name

  socket = UDPSocket.new
  socket.bind "0.0.0.0", in_port.to_i
  puts "Listening on port #{in_port.to_i}"

  loop do
    vector, info = socket.recvfrom 1024
    vector.split("").each_with_index do |letter, index|
      new_vector = "0"*vector.length
      if (letter == "1")
        new_vector[index] = "1"
        word = lexicon[new_vector]
        print "#{word} "
      end
    end
    puts ""
  end
end

def gen_train_pair
  lex_file = ARGV[1]
  pair_file = ARGV[2]

  lexicon, inverted_lexicon = file_to_lexicons lex_file

  File.open pair_file, "r" do |file|
    while !file.eof?
      words = file.readline.split " "
      is_currently_output = false
      input_vector = nil
      output_vector = nil
      words.each do |word|
        if word == "|"
          is_currently_output = true
          next
        end

        if inverted_lexicon[word].nil?
          puts "Word not found #{word}"
          return
        end

        if !is_currently_output
          input_vector = join_vectors inverted_lexicon[word], input_vector
        else
          output_vector = join_vectors inverted_lexicon[word], output_vector
        end
      end

      puts "#{input_vector} #{output_vector}"
    end
  end
end

if ARGV[0] == "help"
  help
elsif ARGV[0] == "gen"
  gen
elsif ARGV[0] == "w2v"
  w2v
elsif ARGV[0] == "w2vi"
  w2vi
elsif ARGV[0] == "v2wi"
  v2wi
elsif ARGV[0] == "gen_train_pair"
  gen_train_pair
else
  help
end

exit

@vectorSize = 0
@lexicon = {}
#Read lexicon file
File.open(file, "r") do |file|
  #First line should be a length
  @vectorSize = file.readline.to_i
  puts "Vector Size: #{@vectorSize}"

  while !file.eof
    line = file.readline
    line_split = line.split(" ")
    index = line_split[0]
    word = line_split[1]
    puts "#{index} => #{word}"
    @lexicon[index.to_i] = word
  end
end
@invertedLexicon = @lexicon.invert


#Vector means you put in 1010 => "WordA Wordb"
#Words means "WordA WordB" => 1010
if type == "vector"
  puts "Started vector[1110->abc] mode 0.0.0.0:#{portFrom} => 0.0.0.0:#{portTo}"
  socket = UDPSocket.new
  socket.bind "0.0.0.0", portFrom.to_i
  loop do
    msg, info = socket.recvfrom 1024
    words = vectorToWords msg
    socket.send words, 0, "0.0.0.0", portTo
  end
#Input
elsif type == "words"
  puts "Started words[abc->1110] mode 0.0.0.0:#{portFrom} => 0.0.0.0:#{portTo}"
  socket = UDPSocket.new
  socket.bind "0.0.0.0", portFrom.to_i
  loop do
    msg, info = socket.recvfrom 1024
    vector = wordsToVector msg
    socket.send vector, 0, "0.0.0.0", portTo
  end
end
