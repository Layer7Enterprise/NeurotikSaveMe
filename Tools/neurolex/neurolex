#! /usr/bin/env ruby

require 'socket'

#10010 => wordA wordC
def vectorToWords vector
  words = []

  vector.split("").each_with_index do |x, i|
    if vector[i] == "1"
      words << @lexicon[i]
    end
  end

  words = words.join(" ")
  return words
end

#wordA wordC => "10010"
def words_to_vector words, inverted_lexicon
  vector = "0"*inverted_lexicon.keys.count

  words.split(" ").uniq.each_with_index do |x, i|
    vector[inverted_lexicon[x]] = "1"
  end

  vector
end

file = ARGV[0]
type = ARGV[1]
portFrom = ARGV[2]
portTo = ARGV[3]

def help
  puts "NeuroLex - Lexicon Swiss Knife"
  puts "[gen]erate a lexicon list from a set of words"
    puts "\tfileIO > gen"
    puts "\t(hint) use > operator to save to a lexicon file"
  puts "[gen_header] to generate a neurotik symbol file"
    puts "\tfileIO > gen_header neuron_set_name"
  puts "Convert a word to vector [w2v]"
    puts "\tw2v file word"
  puts "Convert a word to vector [w2vd] interactively"
    puts "\tw2vi file out_port delay"
  puts "Convert incomming vectors to stdout"
    puts "\tv2wi file in_port"
  puts "Convert incomming vectors to speech"
    puts "\tv2ws file in_port"
  puts "Generate a basic training file for word pairing"
    puts "\tgen_train_pair file pair_file"
    puts "\t(hint) use > operator to save a basic training file"
    puts "\tPair file is seperated pair of words e.g. 'a b\\nc d'"
  exit
end

#Generate a useful header file for accessing the symbolic lexicon names
def gen_header
  words = STDIN.read.split(" ")
  name = ARGV[1]

  puts "#Lexicon symbols"
  words.uniq.each_with_index do |word, index|
    puts "main {alien '_L#{word}', '#{name}', [#{index}, #{index}]}"
  end

  puts "#Leixcon symbol names in a useful array"
  symbol_names = words.uniq.map { |x| "_L#{x}" }
  puts "@lexicon_symbols = #{symbol_names.inspect}"

  puts "#Number of words in the lexicon"
  puts "\nLEXICON_COUNT = #{words.uniq.count}"
end

#Generate lexicon compatible 'stream' from a list of words
def gen
  words = STDIN.read.split(" ")
  inverted_lexicon = {}

  words.uniq.each_with_index do |word, index|
    inverted_lexicon[word] = index
  end

  words.each do |word|
    vector = words_to_vector word, inverted_lexicon
    puts "#{word} #{vector}"
  end
end

def file_to_lexicons file_name
  lexicon = {}
  reverse_lexicon = {}

  File.open file_name, "r" do |file|
    while !file.eof?
      word, vector = file.readline.split(" ")
      lexicon[vector] = word
      reverse_lexicon[word] = vector
    end
  end

  return [lexicon, reverse_lexicon]
end

def w2v
  file_name = ARGV[1]
  word = ARGV[2]

  File.open file_name, "r" do |file|
    while !file.eof?
      vector_word, vector = file.readline.split(" ")
      if word == vector_word
        puts vector
        return
      end
    end
  end
end

def join_vectors vectorA, vectorB=nil
  new_vector = "0" * vectorA.length

  vectorA.length.times do |i|
    if vectorB.nil?
      return vectorA
    elsif
      if vectorA[i] == "1" or vectorB[i] == "1"
        new_vector[i] = "1"
      end
    end
  end

  return new_vector
end

#Interactive mode
def w2vi
  file_name = ARGV[1]
  out_port = ARGV[2]
  delay = ARGV[3]

  lexicon, reverse_lexicon = file_to_lexicons file_name

  socket = UDPSocket.new

  loop do
    words = $stdin.gets.strip.split(" ")
    real_vector = nil
    words.each do |word|
      vector = reverse_lexicon[word]
      if vector.nil?
        puts "Not found..."
        next
      end

      real_vector = join_vectors vector, real_vector
    end

    blank_half = "0"*real_vector.length
    real_vector = real_vector + blank_half

    socket.send real_vector, 0, "127.0.0.1", out_port
    sleep delay.to_f / 1000.0
  end
end

def v2ws
  file_name = ARGV[1]
  in_port = ARGV[2]

  lexicon, reverse_lexicon = file_to_lexicons file_name

  socket = UDPSocket.new
  socket.bind "0.0.0.0", in_port.to_i
  puts "Listening on port #{in_port.to_i}"

  loop do
    vector, info = socket.recvfrom 1024
    sentance = ""
    vector.split("").each_with_index do |letter, index|
      new_vector = "0"*vector.length
      if (letter == "1")
        new_vector[index] = "1"
        word = lexicon[new_vector]
        sentance += " #{word.downcase}"
      end
    end

    `say #{sentance}`
  end
end


def v2wi
  file_name = ARGV[1]
  in_port = ARGV[2]

  lexicon, reverse_lexicon = file_to_lexicons file_name

  socket = UDPSocket.new
  socket.bind "0.0.0.0", in_port.to_i
  puts "Listening on port #{in_port.to_i}"

  loop do
    vector, info = socket.recvfrom 1024
    vector.split("").each_with_index do |letter, index|
      new_vector = "0"*vector.length
      if (letter == "1")
        new_vector[index] = "1"
        word = lexicon[new_vector]
        print "#{word} "
      end
    end
    puts ""
  end
end

#Join ["010", "101"] => "111"
def join_impulse impulses
  output = "0"*impulses[0].length
  impulses.each do |impulse|
    impulse.split("").each_with_index do |letter, index|
      if letter == "1"
        output[index] = "1"
      end
    end
  end

  return output
end

def gen_train_pair
  lex_file = ARGV[1]
  pair_file = ARGV[2]

  lexicon, @inverted_lexicon = file_to_lexicons lex_file

  def get_vector word
    vector = @inverted_lexicon[word] 
    if vector == nil
      $stderr.puts "Did not find word #{word}"
      exit
    end

    return vector
  end

  File.open pair_file, "r" do |file|
    examples = file.read.split("\n")
    examples = examples.map {|x| x.split(" | ")}
    examples = examples.map {|x| {:input =>x[0].split(" "), :output => x[1]}}

    examples.each do |example|
      input = example[:input]
      input = input.map {|x| get_vector(x)}
      output = get_vector(example[:output])

      input.each_with_index do |frag, index|
        #Last
        if index == (input.count - 1)
          puts "#{frag} #{output}"
        else
          puts "#{frag} #{"0"*frag.length}"
        end
      end
      puts "---"
    end

  end
end

#Same as above, no timing
def gen_train_pair_flat
  lex_file = ARGV[1]
  pair_file = ARGV[2]

  lexicon, @inverted_lexicon = file_to_lexicons lex_file

  def get_vector word
    vector = @inverted_lexicon[word] 
    if vector == nil
      $stderr.puts "Did not find word #{word}"
      exit
    end

    return vector
  end

  File.open pair_file, "r" do |file|
    examples = file.read.split("\n")
    examples = examples.map {|x| x.split(" | ")}
    examples = examples.map {|x| {:input =>x[0].split(" "), :output => x[1].split(" ")}}

    examples.each do |example|
      #Merge vectors into one
      input = example[:input]
      input = input.map {|x| get_vector(x)}
      input_real = nil
      input.each do |x|
        input_real = join_vectors x, input_real
      end

      #Merge vectors into one
      output = example[:output]
      output = output.map {|x| get_vector(x)}
      output_real = nil
      output.each do |x|
        output_real = join_vectors x, output_real
      end
      puts "#{input_real} #{output_real}"
      puts "---"
    end
  end
end


if ARGV[0] == "help"
  help
elsif ARGV[0] == "gen"
  gen
elsif ARGV[0] == "gen_header"
  gen_header
elsif ARGV[0] == "w2v"
  w2v
elsif ARGV[0] == "w2vi"
  w2vi
elsif ARGV[0] == "v2wi"
  v2wi
elsif ARGV[0] == "v2ws"
  v2ws
elsif ARGV[0] == "gen_train_pair"
  gen_train_pair
elsif ARGV[0] == "gen_train_pair_flat"
  gen_train_pair_flat
else
  help
end

exit

@vectorSize = 0
@lexicon = {}
#Read lexicon file
File.open(file, "r") do |file|
  #First line should be a length
  @vectorSize = file.readline.to_i
  puts "Vector Size: #{@vectorSize}"

  while !file.eof
    line = file.readline
    line_split = line.split(" ")
    index = line_split[0]
    word = line_split[1]
    puts "#{index} => #{word}"
    @lexicon[index.to_i] = word
  end
end
@invertedLexicon = @lexicon.invert


#Vector means you put in 1010 => "WordA Wordb"
#Words means "WordA WordB" => 1010
if type == "vector"
  puts "Started vector[1110->abc] mode 0.0.0.0:#{portFrom} => 0.0.0.0:#{portTo}"
  socket = UDPSocket.new
  socket.bind "0.0.0.0", portFrom.to_i
  loop do
    msg, info = socket.recvfrom 1024
    words = vectorToWords msg
    socket.send words, 0, "0.0.0.0", portTo
  end
#Input
elsif type == "words"
  puts "Started words[abc->1110] mode 0.0.0.0:#{portFrom} => 0.0.0.0:#{portTo}"
  socket = UDPSocket.new
  socket.bind "0.0.0.0", portFrom.to_i
  loop do
    msg, info = socket.recvfrom 1024
    vector = wordsToVector msg
    socket.send vector, 0, "0.0.0.0", portTo
  end
end
