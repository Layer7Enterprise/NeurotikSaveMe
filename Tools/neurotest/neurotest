#! /usr/bin/env ruby

require 'socket'
require 'timeout'
require 'colorize'

def compare_and_color answer_key, your_answers
  #Convert to arraysx
  answer_key = answer_key.split ""
  your_answers = your_answers.split ""

  corrections = []
  your_answers.each_with_index do |x, i|
    if x != answer_key[i]
      if x == "1"
        corrections << x.red
      elsif x == "0"
        corrections << x.green
      end
    else
      corrections << x
    end
  end

  return corrections.join ""
end

if ARGV.count < 1
  puts "[mode(basic) ....]"
  exit
end

mode = ARGV[0] 

if mode == "basic"
  if ARGV.count != 6
    #DelayBetweenExample = How to long to wait between each example
    puts "basic [inputPort outputPort trainingFile(product/testA.train) delayBetweenExamples attempts]"
    exit
  end

  inputPort = ARGV[1].to_i
  outputPort = ARGV[2].to_i
  trainingFile = ARGV[3]
  delayBetweenExamples = ARGV[4].to_i
  attempts = ARGV[5].to_i

  puts "Loading nbtrain basic file #{trainingFile}, the delay between examples at #{delayBetweenExamples}ms, and sending this data to 0.0.0.0:#{outputPort}, getting data from 0.0.0.0:#{inputPort}.  I will try #{attempts} times"
  examples = {}
  File.open(trainingFile, "r") do |file|
    while !file.eof
      example = file.readline.strip
      next if example == "---"
      example = example.split(" ")
      examples[example[0]] = example[1]
      puts "#{example[0]} => #{example[1]}"
    end
  end

  puts examples

  s = UDPSocket.new
  s.bind "0.0.0.0", inputPort

  failed = {}
  attempts.times do |attempt_index|
    puts "#{attempt_index+1} / #{attempts}"

    randomKey = examples.keys.sample
    randomValue = examples[randomKey]
    #puts "Testing #{randomKey} => #{randomValue}"

    s.send(randomKey + "0"*randomValue.length, 0, "0.0.0.0", outputPort)
    begin
      timeout(0.3) do
        msg, info = s.recvfrom 1024
        if msg != randomValue
          randomKey = compare_and_color randomValue, msg
          puts "failed"
          failed[randomKey] = 0 if failed[randomKey].nil?
          failed[randomKey] += 1
        end
      end
    rescue
      puts "failed"
      failed[randomKey] = 0 if failed[randomKey].nil?
      failed[randomKey] += 1
    end

    sleep delayBetweenExamples / 1000.0
  end

  count = 0
  failed.each do |k, v|
    count += v
  end
  #tab_fail = failed.inject(0) {|total, e| total + e}
  #
  sortable_container = []
  failed.each do |k, v|
    sortable_container << {:key => k, :value => v}
  end

  sortable_container.sort!{|x, y| x[:key].to_f <=> y[:key].to_f}

  puts "########################"
  sortable_container.each do |error|
    puts "#{error[:key]} : #{(error[:value] / attempts.to_f*100).to_s[0..8]}%"
  end
  puts "########################"
  puts "\nFailed: #{count / attempts.to_f * 100}%"
else
  puts "Not a mode"
  exit
end
